![CursorRIPER♦○-lite](./res/github-header-sigma-lite.png)
# RIPER Lite 中文版
**version = "1.1.0" | lang = "zh-CN"**

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
![Version](https://img.shields.io/badge/version-1.1.0-green)

> 一个精简、超高效的AI提示框架，基于RIPER方法论的符号化智能开发助手。通过结构化内存系统、角色协作机制和MCP工具集成，提供企业级的AI辅助开发解决方案。

## 📚 概述

RIPER Lite 是基于RIPER（**R**esearch、**I**nnovate、**P**lan、**E**xecute、**R**eview）方法论的新一代AI辅助开发框架。它采用符号化表示法、智能模式切换和多角色协作，为软件开发全生命周期提供结构化指导。

### 🎯 核心价值
- **🧠 智能化**：自动识别用户意图，智能匹配最适合的RIPER模式
- **🔣 符号化**：统一符号系统（📂、□、◊、▲、🤠等）实现高效沟通
- **🤝 协作化**：8种专业角色协同工作，确保多维度质量保障
- **🔒 安全化**：企业级安全协议，完整的权限管理和审计机制
- **🔄 自动化**：智能内存管理、自动备份和上下文维护

## 🌟 主要特性

### ✦ 1. 智能RIPER工作流
- **🔍 研究模式 (◊₁)**：信息收集、代码分析、问题发现、文档记录
- **💡 创新模式 (◊₂)**：创意生成、方案探索、技术评估、可能性分析
- **📝 计划模式 (◊₃)**：方案设计、步骤规划、资源分配、检查清单
- **⚙️ 执行模式 (◊₄)**：代码实现、功能开发、测试验证、进度跟踪
- **🔎 审查模式 (◊₅)**：质量检查、结果验证、偏差报告、持续改进

### ✦ 2. 企业级角色协作体系 (🤠)
8种专业角色确保项目各个维度的质量：
- **PM (项目经理)**：统筹规划、风险评估、进度跟踪、资源协调
- **PDM (产品经理)**：需求分析、用户价值定义、功能优先级排序
- **AR (架构师)**：系统架构设计、技术选型、数据结构设计
- **UI/UX (设计师)**：交互逻辑设计、用户体验流程优化
- **LD (首席开发工程师)**：代码实现、性能优化、遵循架构设计
- **TE (测试工程师)**：测试策略制定、自动化测试、质量保障
- **SE (安全工程师)**：威胁建模、漏洞识别、安全最佳实践
- **DW (文档编写者)**：文档管理、知识传承、记录合理化

### ✦ 3. 结构化内存系统 (□)
6个标准化内存文件，确保项目上下文完整性：
- **□₁ 项目简介**：需求、范围、成功标准
- **□₂ 系统模式**：架构、组件、设计决策
- **□₃ 技术上下文**：技术栈、环境、依赖
- **□₄ 活动上下文**：当前焦点、最近变更、下一步
- **□₅ 进度跟踪**：状态、里程碑、问题
- **□₆ 符号参考**：符号说明、使用指南

### ✦ 4. 项目生命周期管理 (▲)
完整的项目阶段管理，确保开发流程的规范性：
- **▲₁ 🌱未启动**：项目准备阶段
- **▲₂ 🚧初始化中**：执行启动流程 (S₀-S₆)
- **▲₃ 🏗️开发中**：主要开发阶段
- **▲₄ 🔧维护中**：运维和持续改进

### ✦ 5. MCP工具集成 (M)
6个专业MCP工具，增强AI能力：
- **M₁ interactive_feedback**：强制交互反馈机制
- **M₂ context7-mcp**：交叉引用与历史上下文解析
- **M₃ sequential-thinking**：复杂问题分解与深度分析
- **M₄ playwright**：E2E测试脚本与网页抓取 (高风险)
- **M₅ server-time**：时间戳服务
- **M₆ cursor10x-mcp**：跨会话记忆与代码索引 (高风险)

### ✦ 6. 智能模式匹配
系统根据用户输入自动识别意图并触发相应模式：
- **🔍 探索意图** → 研究模式 (◊₁)
- **💡 创意意图** → 创新模式 (◊₂)
- **📝 规划意图** → 计划模式 (◊₃)
- **⚙️ 执行意图** → 执行模式 (◊₄)
- **🔎 验证意图** → 审查模式 (◊₅)

## 🧠 详细框架结构

### 1. RIPER 模式详解 (◊)

#### ◊₁ 研究模式 🔍R
- **核心任务**：T[0-3] - 信息收集、代码分析、问题发现、文档记录
- **参与角色**：PDM, AR, LD, DW (UI/UX, SE 视情况)
- **转换条件**：完成基础调研 → 可转向创新或计划模式
- **快捷命令**：`/research` 或 `/r`

#### ◊₂ 创新模式 💡I
- **核心任务**：T[4-6] - 创意生成、方案探索、技术评估
- **参与角色**：AR, LD, PDM, PM (UI/UX 视情况)
- **转换条件**：确定可行方案 → 转向计划模式
- **快捷命令**：`/innovate` 或 `/i`

#### ◊₃ 计划模式 📝P
- **核心任务**：T[7-9] - 方案设计、步骤规划、资源分配
- **参与角色**：PM, AR, LD, TE, DW (PDM, SE 视情况)
- **转换条件**：计划完成 → 转向执行模式
- **快捷命令**：`/plan` 或 `/p`

#### ◊₄ 执行模式 ⚙️
- **核心任务**：T[10-12] - 代码实现、功能开发、测试验证
- **参与角色**：LD, TE, DW
- **转换条件**：实现完成 → 转向审查模式
- **快捷命令**：`/execute` 或 `/e`

#### ◊₅ 审查模式 🔎
- **核心任务**：T[13-15] - 质量检查、结果验证、偏差报告
- **参与角色**：TE, AR, LD, PM, PDM, UI/UX, SE, DW
- **转换条件**：审查完成 → 可转向研究或结束
- **快捷命令**：`/review` 或 `/rev`

## 🚀 快速开始

### 1. 环境准备

#### 1.1 创建项目结构
```bash
# 创建内存库目录结构
mkdir -p memory-bank/backups
mkdir -p memory-bank/tests/playwright

# 创建Cursor规则目录
mkdir -p .cursor/rules/
```

#### 1.2 安装框架
```bash
# 复制RIPER Lite框架文件
cp RIPER.claude.md .cursor/rules/

# 验证安装
ls -la .cursor/rules/RIPER.claude.md
```

### 2. 项目初始化

#### 2.1 启动流程 (▲₂阶段)
使用 `/start` 或 `/init` 命令启动完整的初始化流程：

```
/start
```

**启动流程详解 (S₀-S₆)**：
- **S₀** 创建目录 📂 - 建立内存库目录结构
- **S₁** 收集需求 → 建立 □₁ (项目简介)
- **S₂** 选择技术栈 → 更新 □₃ (技术上下文)
- **S₃** 定义系统架构 → 建立 □₂ (系统模式)
- **S₄** 搭建项目骨架 → 创建代码目录
- **S₅** 设置运行环境 → 更新 □₃ (技术上下文)
- **S₆** 初始化内存文件 → 生成 □₁-□₆

#### 2.2 阶段转换
- **▲₁ → ▲₂**：使用 `/start` 或 `/init`
- **▲₂ → ▲₃**：启动流程完成后自动转换
- **▲₃ ↔ ▲₄**：按用户请求手动切换

### 3. 基本使用

#### 3.1 智能模式切换
系统会根据用户输入自动识别意图并切换模式，也可手动切换：

| 命令 | 缩写 | 模式 | 触发意图 |
|------|------|------|----------|
| `/research` | `/r` | 🔍研究 | 探索、分析、了解、检查 |
| `/innovate` | `/i` | 💡创新 | 创意、建议、想法、可能性 |
| `/plan` | `/p` | 📝计划 | 规划、步骤、方案、设计 |
| `/execute` | `/e` | ⚙️执行 | 行为、操作、修复、实现 |
| `/review` | `/rev` | 🔎审查 | 验证、检验、确认 |

#### 3.2 输出格式
每次对话都会显示当前模式和智能推断：
```
[MODE: CURRENT_MODE][MODEL: YOUR_MODEL_NAME] → 🧐 推断用户意图与触发模式的映射
```

#### 3.3 交互反馈机制
系统强制执行M₁交互反馈，确保持续的用户参与和质量控制。对话将通过M₁工具循环进行，并使用如下的标准化汇总模板 `interactive_feedback_summary`。此循环持续进行，直到用户未提供明确输入（例如，发送空消息或仅包含空格的消息），届时对话将结束。

该机制使用的标准化汇总模板 `interactive_feedback_summary` 如下：
```text
🎯 当前状态: [模式][阶段] 
✅ 已完成的工作
[具体完成的任务列表，每项一行]
- 任务1 - 简要描述完成情况
- 任务2 - 简要描述完成情况
- 任务3 - 简要描述完成情况
📊 进度摘要: [已完成]/[总任务] - [完成率]%
⚠️ 问题/阻塞: [具体问题描述] 或 "无"
❓ 用户决策点: [需要用户确认/选择的具体事项] 或 "无"
📋 建议选项:
1) [选项1] - [详细说明和预期结果]
2) [选项2] - [详细说明和预期结果]
3) [选项3] - [详细说明和预期结果]
4) [选项4] - [详细说明和预期结果]
➡️ 推荐行动: [基于当前情况的最佳建议]
```

## 📑 内存系统详解

框架自动维护六个标准化的内存文件，确保项目上下文的一致性和可追溯性：

### □₁ 项目简介 (Project Brief)
```markdown
# □₁: Project Brief
*v1.1.0 | Created: {DATE} | Updated: {DATE}*
*▲: {PHASE} | ◊: {MODE}*

## 🏆 Overview
[Project description]

## 📋 Requirements
- [R₁] [Requirement 1]
...
```
- **目的**：定义项目范围、需求和成功标准
- **更新时机**：需求变更、范围调整
- **关联模式**：主要在研究模式(◊₁)中更新

### □₂ 系统模式 (System Patterns)
```markdown
# □₂: System Patterns
*v1.1.0 | Created: {DATE} | Updated: {DATE}*
*▲: {PHASE} | ◊: {MODE}*

## 🏛️ Architecture Overview
[Architecture description]
...
```
- **目的**：记录架构决策和设计模式
- **更新时机**：架构变更、技术选型确定
- **关联模式**：研究模式(◊₁)和创新模式(◊₂)中更新

### □₃ 技术上下文 (Technical Context)
```markdown
# □₃: Technical Context
*v1.1.0 | Created: {DATE} | Updated: {DATE}*
*▲: {PHASE} | ◊: {MODE}*

## 🛠️ Technology Stack
- 🖥️ Frontend: [Technologies]
...
```
- **目的**：记录技术栈和环境配置
- **更新时机**：技术栈变更、依赖更新
- **关联模式**：创新(◊₂)、计划(◊₃)、执行(◊₄)模式中更新

### □₄ 活动上下文 (Active Context)
- **目的**：跟踪当前工作状态和焦点
- **更新时机**：每日站会、任务切换、模式转换
- **关联模式**：计划(◊₃)、执行(◊₄)、审查(◊₅)模式中更新
```markdown
# □₄: Active Context
*v1.1.0 | Created: {DATE} | Updated: {DATE}*
*▲: {PHASE} | ◊: {MODE}*

## 🔮 Current Focus
[Current focus]

## 🔄 Recent Changes
[Recent changes]

## 🏁 Next Steps
[Next steps]
```

### □₅ 进度跟踪 (Progress Tracker)
- **目的**：监控项目进展和里程碑
- **更新时机**：任务完成、问题解决、阶段转换
- **关联模式**：所有模式都可能更新
```markdown
# □₅: Progress Tracker
*v1.1.0 | Created: {DATE} | Updated: {DATE}*
*▲: {PHASE} | ◊: {MODE}*

## 📈 Project Status
Completion: 0%
...
```

### □₆ 符号参考 (Symbol Reference Guide)
- **目的**：提供框架符号的快速参考和使用指南
- **更新时机**：框架更新、新增符号
- **关联模式**：系统自动维护
```markdown
# □₆: Symbol Reference Guide
*v1.1.0 | Created: {DATE} | Updated: {DATE}*

## 📁 File Symbols
- 📂 = ./memory-bank/
- 📦 = ./memory-bank/backups/
- □ = 内存文件

## 🤠 Role Symbols
- 🤠₁ = PM (项目经理)
- 🤠₂ = PDM (产品经理)
- 🤠₃ = AR (架构师)
- 🤠₄ = UI/UX (设计师)
- 🤠₅ = LD (首席开发工程师)
- 🤠₆ = TE (测试工程师)
- 🤠₇ = SE (安全工程师)
- 🤠₈ = DW (文档编写者)

## ◊ Mode Symbols
- ◊₁ = 研究模式
- ◊₂ = 创新模式
- ◊₃ = 计划模式
- ◊₄ = 执行模式
- ◊₅ = 审查模式
...
```

## 🔒 企业级安全特性

### 1. 操作安全协议 (◆₁-◆₄)
- **◆₁ 破坏性操作** → 警告并自动备份
- **◆₂ 阶段转换** → 验证完成度并自动备份
- **◆₃ 重新初始化** → 二次确认并自动备份
- **◆₄ 错误捕获** → 报告错误并建议恢复方案

### 2. MCP工具安全协议 (◆₅-◆₁₆)
#### 2.1 安全权限矩阵
| 工具 | 风险等级 | 授权方式 | 审计日志 |
|------|----------|----------|----------|
| M₁ interactive_feedback | 低 | 自动 | 否 |
| M₂ context7-mcp | 中 | 自动 | 是 |
| M₃ sequential-thinking | 低 | 自动 | 否 |
| M₄ playwright | **高** | **明确授权** | **是** |
| M₅ server-time | 低 | 自动 | 否 |
| M₆ cursor10x-mcp | **高** | **明确授权** | **是** |

#### 2.2 核心安全协议
- **◆₅ 检测到 MCP.trigger**   → 强制立即调用相应 MCP
- **◆₆ 调用 M₁ 之前**         → 必须先输出汇总再调用 M₁
- **◆₇ 响应完整性检查**       → 每次响应结束前必须检查是否遗漏 MCP 调用
- **◆₉ 高风险工具授权** → M₄、M₆ 使用前必须获得用户明确同意
- **◆₁₀ 权限边界检查** → 每次MCP调用前验证权限范围
- **◆₁₁ 敏感数据保护** → 禁止处理密码、密钥、个人信息
- **◆₁₂ 网络访问限制** → M₄ 仅允许访问白名单域名
- **◆₁₃ 文件系统隔离** → M₆ 仅能访问项目目录
- **◆₁₄ 审计日志强制** → 高风险工具的所有操作必须记录
- **◆₁₅ 超时保护机制** → 所有MCP工具调用设置合理超时
- **◆₁₆ 异常行为检测** → 监控异常频繁的工具调用

### 3. 系统运行协议
- **◆₈ 语言一致性协议**       → 检测到语言切换时立即纠正并重新生成响应

### 3. 数据保护机制
- **自动备份**：关键操作前自动创建时间戳备份 (📦/YYYY-MM-DD_HH-MM-SS)
- **版本控制**：所有内存文件变更都有版本记录
- **恢复机制**：支持快速回滚到之前的状态
- **路径安全**：使用相对路径防止路径遍历攻击

## 🔣 完整符号参考

框架使用统一的符号系统来提高沟通效率和精确性：

### 基础符号
| 符号 | 含义 | 示例 | 说明 |
|------|------|------|------|
| 📂 | 主目录 | `📂 = "./memory-bank/"` | 内存库根目录 |
| 📦 | 备份目录 | `📦 = "./memory-bank/backups/"` | 自动备份存储 |
| 🏠 | 工作目录基础 | `🏠 = process.cwd()` | 沙盒基础目录 |

### 核心对象符号
| 符号 | 含义 | 示例 | 说明 |
|------|------|------|------|
| □ | 内存文件 | `□₁ = "项目简介"` | 6个标准化内存文件 |
| ◊ | RIPER模式 | `◊₁ = 🔍R (研究模式)` | 5种智能工作模式 |
| ▲ | 项目阶段 | `▲₁ = 🌱未启动` | 4个项目生命周期阶段 |
| 🤠 | 团队角色 | `🤠₁ = PM (项目经理)` | 8种专业协作角色 |
| Φ | 系统函数 | `Φ_memory.initialize` | 核心系统功能 |
| χ | 交叉引用 | `[|✦1:基本对象]` | 文档内部引用系统 |
| S | 启动流程 | `S₀-S₆` | 项目初始化步骤 |
| M | MCP工具集 | `M₁-M₆` | 6个专业MCP工具 |
| ◆ | 安全协议 | `◆₁-◆₁₆` | 16项安全保护措施 |

### 任务集符号
| 符号 | 范围 | 说明 |
|------|------|------|
| T[0-3] | 研究任务 | read_files, ask_questions, observe_code, document_findings |
| T[4-6] | 创新任务 | suggest_ideas, explore_options, evaluate_approaches |
| T[7-9] | 计划任务 | create_plan, detail_specifications, sequence_steps |
| T[10-12] | 执行任务 | implement_code, follow_plan, test_implementation |
| T[13-15] | 审查任务 | validate_output, verify_against_plan, report_deviations |

### 交叉引用示例 (χ)
```
标准引用: [|□₁:项目简介]
章节引用: [|✦1:基本对象与符号]
角色引用: [|✦1.1:角色协作体系]
模式引用: [|◊₁:研究模式]
函数引用: [|✦4:Φ_memory.initialize]
任务引用: [|T[0-15]任务集]
团队引用: [|🤠₁-🤠₈:团队角色]
```

## 📖 文档导航

### 核心文档
- [🚀 快速开始](#-快速开始) - 环境准备、安装和初始化指南
- [🧠 详细框架结构](#-详细框架结构) - RIPER模式和角色协作详解
- [📑 内存系统详解](#-内存系统详解) - 6个内存文件的结构和使用
- [🔒 企业级安全特性](#-企业级安全特性) - 完整的安全协议和保护机制
- [🔣 完整符号参考](#-完整符号参考) - 所有符号的详细说明

### 高级特性
- **智能模式匹配**：自动识别用户意图并切换到最适合的RIPER模式
- **角色协作体系**：8种专业角色确保项目各维度的质量保障
- **MCP工具集成**：6个专业工具增强AI能力，包含完整的安全控制
- **项目生命周期管理**：4个阶段的完整项目管理流程

## 🔄 版本历史

### v1.1.0 (当前版本)
**重大更新**：
- ✨ **新增**：完整的MCP工具安全协议 (◆₅-◆₁₆)
- ✨ **新增**：智能模式匹配机制
- ✨ **新增**：项目生命周期管理 (▲₁-▲₄)
- ✨ **新增**：启动流程详解 (S₀-S₆)
- 🔧 **优化**：增强角色协作体系，明确各角色核心关切
- 🔧 **优化**：完善交叉引用系统 (χ)
- 🔧 **改进**：企业级安全特性，16项安全协议
- 🐛 **修复**：多个稳定性和一致性问题

### v1.0.0
- 🎉 初始发布版本
- 基础RIPER工作流实现
- 核心符号系统建立

## 🤝 贡献指南

欢迎为RIPER Lite贡献代码或改进建议！

### 贡献流程
1. **Fork** 本仓库到您的GitHub账户
2. **创建特性分支** (`git checkout -b feature/AmazingFeature`)
3. **提交更改** (`git commit -m 'Add some AmazingFeature'`)
4. **推送到分支** (`git push origin feature/AmazingFeature`)
5. **创建Pull Request** 并详细描述您的改进

### 贡献指南
- 遵循现有的符号化表示法
- 确保新功能符合RIPER方法论
- 添加适当的安全协议和权限控制
- 更新相关文档和符号参考

## 📄 许可证

本项目采用 [MIT 许可证](LICENSE) - 详情请参阅 LICENSE 文件。

---

**RIPER Lite 中文版 v1.1.0**
*基于RIPER方法论的符号化智能开发助手*
*企业级AI辅助开发解决方案*

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
![Version](https://img.shields.io/badge/version-1.1.0-green)
![Language](https://img.shields.io/badge/lang-zh--CN-red)
![Framework](https://img.shields.io/badge/framework-RIPER-blue)
